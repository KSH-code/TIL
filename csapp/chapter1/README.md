# 컴퓨터 시스템
하드웨어와 시스템 소프트웨어로 구성되며, 함께 작동하여 응용프로그램을 실행한다.
## 시스템의 구현방법
시간에 따라 바뀔 수 있지만, 근본적인 방법은 바뀌지 않는다.

모든 컴퓨터 시스템들은 유사한 기능을 수행하는 유사한 하드웨어와 소프트웨어 컴포넌트를 가지고 있다.

우리는 컴포넌트들이 어떻게 동작하고 프로그램의 성능과 정확성에 어떤 영향을 주는지 알아보자.

[hello.c](hello.c) 를 실행하면 어떻게 시스템에서 실행되고, 출력되고, 종료될 때 까지의 수명주기를 추적한다.
# 1. 정보는 비트와 컨텍스트로 이루어진다.
hello.c 는 텍스트 파일이다.

소스 프로그램은 2진수의 연속이고, 바이트로 구성된다.

각 바이트는 텍스트 문자를 나타낸다. (ASCII 표준 사용)

아스키 문자들로만 이루어진 파일들을 *텍스트 파일* 이라고 부른다.

아니면 *바이너리 파일* 이라고 한다.

모든 시스템 내부의 정보와 데이터는 비트(binary number)들로 표시된다.
# 2. 프로그램은 다름 프로그램에 의해 다른 형태로 번역됨
hello 프로그램은 텍스트 파일이여서 사람이 이해할 수 있다.

hello.c 를 시스템에서 실행시키려면, 저급 *기계어 인스트럭션*들로 번역해야 된다.

이 인스트럭션들은 실행가능 *목적 프로그램*이라는 형태로 합쳐지고 바이너리 디스크 파일로 저장된다.

목적프로그램은 실행 가능 *목적 파일*로도 부른다.
# GCC 컴파일 시스템의 단계
1. 전처리 단계
    * 전처리기는 # 문자로 시작하는 디렉티브에 따라 수정한다. #include <stdio.h> 가 있다고 가정하면, stdio.h 헤더 파일을 직접 넣어준다.
    * 결과적으로는 .i 파일이 생성된다. (hello.i)
2. 컴파일 단계
    * 텍스트 파일 .i 를 .s 형태로 변역한다. .s 에는 *어셈블리어 프로그램*이 저장된다. (hello.s)
3. 어셈블리 단계
    * .s 를 기계어 인스트럭션으로 번역하고, 재배치가능 목적프로그램의 형태로 묶어서 .o 로 저장한다.
4. 링크 단계
    * printf 함수 즉 표준 라이브러리에 들어있는 함수를 호출해야 된다. printf 는 printf.o 에 저장돼있으며, hello.o 와 결합되어야 한다.
    * 이 작업을 링커프로그램이 하며, hello 파일은 실행가능 목적파일(즉 실행파일 .exe?)로 메모리에 적재되어 실행된다.
# 3. 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다
`hello.c` 처럼 간단한 프로그램의 경우 컴파일 시스템이 정확하고 효율적인 기계어 코드를 만들어 줄 거라고 기대할 수 있다.

하지만 프로그래머들은 어떻게 컴파일이 되는지 알 필요가 있다.
* 프로그램 성능 최적화하기
    * if-else 가 switch 보다 빠를까?
    * while-loop 이 for-loop 보다 빠를까?
    * 합계를 지역변수에 저장하면 참조 형태로 넘겨받는 인자를 사용하는 것보다 왜 loop 이 더 빨리 실행될까?
* 링크 에러 이해하기
    * 정적변수와 전역변수의 차이는 무엇인가?
    * 각기 다른 파일에서 같은 이름의 전역변수를 정의한다면?
    * 정적 라이브러리와 동적 라이브러리의 차이점은?
* 보안 약점
    * 방어하는 방법을 배운다
# 4. 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다
`hello.c` 소스 프로그램은 컴파일 시스템에 의해 실행 가능한 목적 파일로 디스크에 변환된다.
# 4.1 시스템의 하드웨어 조직
* Buses (Bus)
    * 시스템 내를 관통하는 전기적 배선군
    * 컴포넌트들 간에 바이트 정보 전송
    * 일반적으로 word
        * 32 비트 4 바이트
        * 64 비트 8 바이트
* I/O 장치
    * 입력
        * 키보드
        * 마우스
    * 출력
        * 디스플레이
        * 디스크 드라이브
    * 입출력 버스와 컨트롤러나 어댑터를 통해 연결
* 메인 메모리
    * 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치
    * 물리적 DRAM(Dynamic Random Access Memory)
    * 연속적인 바이트들의 배열
* 프로세서
    * 메인 메모리에 저장된 인스트럭션들을 해독
    * 중심에 워드 크기의 저장장치 (또는 레지스터) 인 PC(Program Counter) 가 있다.
    * PC 가 가르키는 곳의 인스트럭션을 반복적 실행
    * PC 의 다음 인스트럭션의 위치 업데이트
    * 순환
        * 메인 메모리
        * 레지스터 파일
        * 수식/논리 처리기(ALU)
    * 단순 작업
        * Load 메인 메모리에서 레지스터에 바이트 또는 워드를 덮어씌움
        * Store 레지스터에서 메인 메모리로 바이트 또는 워드를 이전 값을 덮어씌움
        * Operate 두 레지스터의 값을 ALU 로 복사 -> 두 개의 워드로 수식 연산 후 덮어씌움
        * Jump 인스트럭션 자신으로부터 워드 추출 PC 에 덮어씌움
# 4.2 hello 프로그램의 실행
* 쉘 프로그램은 자신의 인스트럭션 실행
* 사용자 명령 입력 대기
* 입력되면 문자를 레지스터에 읽어드림
* 메모리 저장
1. I/O 장치 ->  I/O bus 를 통해 -> I/O bridge -> System bus 를 통해 -> Bus interface -> Register file -> System bus 를 통해 -> I/O bridge -> Memory bus 를 통해 -> Main memory
2. Disk -> I/O bus 를 통해 -> I/O bridge -> Memory bus 를 통해 -> Main memory
3. Main memory -> Memory bus 를 통해 -> I/O bridge -> System bus 를 통해 -> Bus interface -> Register file -> Bus interface -> System bus 를 통해 -> I/O bridge -> I/O bus 를 통해 -> Display
1. 키보드 입력
2. 실행 파일 로드
3. 출력