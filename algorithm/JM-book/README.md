# 2
## 문제 해결 알고리즘
1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의 (이거는 굳이 안해도 될듯함)
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현
6. 어떻게 풀었는지 돌아보고, 개선 방법 찾는다. (이거는 시간 남으면)
### 1. 문제를 읽고 이해하기
* 모든 공통 실수는 문제를 잘못 읽는 실수다.
### 2. 재정의와 추상화
* 자신의 언어로 문제를 풀어쓴다.
* 문제의 추상화가 필요하다.
  * 여기서 추상화란 수학적/전산학적 개념으로 옮겨 표현하는 과정
### 3. 계획 세우기
* 사용할 알고리즘, 자로구조 선택
### 4. 계획 검증
* 알고리즘이 잘 돌아가는지, 자료구조가 적절한지를 확인한다.
### 5. 계획 수행하기
* 구현
### 6. 회고하기
* 다시 풀어보면 더 좋은 방법을 찾을 수 있다.
* 만약 오답이였으면, 오답 노트를 적어라
### 문제를 풀지 못할 때
* 참고해라 다른 답을
  * 하지만 참고하고, 내가 접근했던 방법을 확인해라
## 문제 해결 전략
어려운 문제일수록 다양한 방법을 시도해야 된다.
### 직관과 체계적인 접근
* 문제와 답의 구조에 대한 직관의 중요성
* 해당 문제를 해결하는 알고리즘이 대략적으로 어떤 형태를 가질지를 짐작할 수 있게 해준다.
* 직관을 발달시키려면 막막한 문제들을 해결하며 실력을 늘려야된다.
### 체계적인 접근 위한 질문
* 비슷한 문제를 풀어봤나?
  * 비슷한 문제여도 응용 문제를 많이 풀어봐라
* 단순한 방법에서 시작할 수 있을까?
  * 무식하게 푼다 -> 리팩토링의 반복
* 문제를 푸는 과정을 수식화할 수 있을까?
  * 손으로 풀고, 그 공식을 알고리즘으로 만들 수 있다.
* 문제를 단순화할 수 없을까?
  * 좀더 쉬운 문제를 풀고, 어려운 문제를 풀어는것도 좋다.
  * 더 단순화 방법
    * 제약 조건을 없에본다.
    * 변수의 수를 줄인다.
    * 다차원의 문제를 1차원으로 변경해서 풀어본다.
* 그림으로 그려보자
  * 문제에 관련된 그림을 그려본다.
* 수식으로 표현할 수 있나?
  * 평문을 수식으로 표현하면 도움이 될 때가 있다.
* 분해해보자
  * 제약 조건을 분해한다.
* 뒤에서부터 생각해서 문제를 풀 수 있을까?
  * 사다리타기를 예로 들어보면 밑에서부터 위로 올라가는 것이다.
* 순서를 강제로 정해보자
  * 순서를 정해준다. (내 마음대로)
### How to solve it (번역한거였음)
문제 해결에 있어 단양한 전략들을 나열한다.
# 3
## 코딩의 중요성을 간과하지 말라
* 프로그래밍 대회 입상자의 코드는 대부분 간결하고 이해하기 쉽다.
## 좋은 코드를 작성하는 방법
* 간결한 코드 작성
  * 코드가 짧을수록 오타가 줄어든다.
  * 매크로를 사용하면 변수 실수가 없을 수 있다. (그래도 사용하지 말자...)
* 적극적 코드 재사용
  * 코드를 모듈화해라
* 표준 라이브러리 공부하기
* 항상 같은 형태로 프로그램을 작성하기
  * 검증된 코드를 작성하는걸 노력해라
* 일관적이고 명료한 명명법 사용하기
  * 변수명, 함수명
* 코드와 데이터 분리
  * ex ) monthName 배열 사용, daysIn (월 마다 일 수)
## 자주 하는 실수
* 산술 오버플로
* 배열 범위 밖 원소에 접근
* 일관되지 않은 범위 표현 방식 사용하기
  * 닫힌 구간
    * [2, 12]
    * = 2 <= i <= 12
  * 열린 구간
    * (2, 12)
    * = 2 < i < 12
* 최소, 최대 예외 잘못 다루기
* 연산자 우선순위 잘못 쓰기
  * 비트단위 연산자는 우선순위가 낮다.
* 너무 느린 입출력 방식
  * cin, cout, scanner
* 변수 초기화 문제
  * 두 번째 입력을 생각하지 않은경우
## 디버깅과 테스팅
* 디버깅에 관하여
  * 프로그래밍 대회에서는 소스코드를 눈으로 디버깅이 가능하다. (짧음)
  * ACM-ICPC 의 경우는 한 명이 코더기 때문에 더 가능
  * 작은 입력값으로 간단하게 확인
  * 단정문을 쓴다. (주어진 조건이 거짓일 때 오류, 강제종료)
  * 계산 중간결과 출력
* 테스트에 관하여
  * 스캐폴딩 기법
    * 맞왜틀인 경우에 사용한다.
    * 답안을 검증하는 코드를 작성한다.
    * 대회에서는 라이브러리를 사용 못해서 거의 힘들다
      * 표준 라이브러리로 정렬한 값, 내가 구현한 정렬의 값 비교
## 변수 범위의 이해
### 산술 오버플로
컴퓨터는 수학자들이 만든 기계이며 수학에 따라 움직인다.

현실 세계에 존재하는 물건이라 엄연한 제한이 있다.

* 유한성: 수학에서 변수 n 이 있다면, 제한이 없다.

  하지만 컴퓨터에서는 제한이 있다.
  * 사칙 연산 과정의 오버플로 (에러가 나도 오버플로가 나는걸 알려주지 않는다.(연산시마다 알려주면 오버헤드가 크다.))